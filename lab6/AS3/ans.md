# 1. 实现过程
```assembly
00000000 <BankMove>:
0:  000502b3    add x5,x10,x0
4:  00058333    add x6,x11,x0
8:  000603b3    add x7,x12,x0

0000000c <L1>:
c:  0002ae03    lw x28,0(x5)
10: 01c32023    sw x28,0(x6)
14: 0291        c.addi x5,4
16: 0311        c.addi x6,4
18: 13fd        c.addi x7,-1
1a: fe0399e3    bne x7,x0,c <L1>
1e: 8082        c.jr x1

00000020 <main>:
20: 03000513    addi x10,x0,48
24: 06000593    addi x11,x0,96
28: 4629        c.li x12,10
2a: 3fd9        c.jal 0 <BankMove>
```

## 1.1 子程序调用  
1. `x5` 寄存器存储源数据区域首址，`x6` 寄存器存储目的数据区域首址，`x7` 寄存器存储数据块长度（需转移数据的个数）
2. 利用 `x28` 寄存器作为中间载体，将 `Mem[x5]` 转移至 `Mem[x6]`，循环 10 次
3. 每循环一次，`x5` 和 `x6` 寄存器均加 4（4 个字节，即 1 个字数据的长度），`x7` 寄存器减 1（循环减少一次）

## 1.2 子程序返回
1. 程序出口处设有条件分支语句 `bne x7,x0,c <L1>`，若 `x7 != x0`，则跳转至标签 `L1` 处，代表继续循环
2. 若 `x7 == x0`，则顺序执行下一条语句 `c.jr x1`，返回主程序

# 2. `jal` 和 `jr` 的机器代码解析
## 2.1 `2a: 3fd9  c.jal 0 <BankMove>`
- `3fd9H` = `0011_1111_1101_1001B`
- `c.jal 0 <BankMove>` = `jal x1, offset`

### 2.1.1 转移地址 
- `offset` = `11111101011B` = `-21D`
- `addr` = `PC + SE32(2*offset)` = `2aH + -42D` = `0000_0000H`

### 2.1.2 指令的操作与结果
操作：
- `PC + 2 -> x1`
- `PC + SE32(2*offset) -> PC`
  
结果：
- `x1` 寄存器保存子程序返回时的指令地址
- `PC` 跳转至地址 `0000_0000H` 处，执行子程序

### 2.1.3 跳转目标地址的指令 
- `jal x1, offset`

## 2.2 `1e: 8082  c.jr x1`
- `8082H` = `1000_0000_1000_0010B`
- `c.jr x1` = `jalr x0, 0(x1)`

### 2.2.1 转移地址
- `addr` = `x1` = `0000_002cH`

### 2.2.2 指令的操作与结果
操作：
- `PC` 跳转至 `x1` 寄存器存储的地址 `0000_002cH` 处

结果：
- 子程序 `BankMove` 调用结束，回到主程序 `main`

### 2.2.3 跳转目标地址的指令
- `jalr x0, 0(x1)`

# 3. 补充分析

和 **AS2** 一样，本实验也可以通过同样的方法 **反汇编** 出 **32位** 的指令,以下为对应的 **汇编指令** 、**机器指令**

```assembly
00000000 <BankMove>:
   0:	000502b3          	add	t0,a0,zero
   4:	00058333          	add	t1,a1,zero
   8:	000603b3          	add	t2,a2,zero

0000000c <L1>:
   c:	0002ae03          	lw	t3,0(t0)
  10:	01c32023          	sw	t3,0(t1)
  14:	00428293          	add	t0,t0,4
  18:	00430313          	add	t1,t1,4
  1c:	fff38393          	add	t2,t2,-1
  20:	fe0396e3          	bnez	t2,c <L1>
  24:	00008067          	ret

00000028 <main>:
  28:	03000513          	li	a0,48
  2c:	06000593          	li	a1,96
  30:	00a00613          	li	a2,10
  34:	fcdff0ef          	jal	0 <BankMove>
```

## 3.1 `jal	0 <BankMove>`

`fcdff0efH` = `1111_1100_1101_1111_1111_0000_1110_1111B`
对照 **RICV指令格式** 可知该指令属于 `jal` 指令

`imm` = `1111_1100_1101_1111_1111`

`rd` = `00001 (x1)`

根据 **立即数的拼接规则** ，可得 `offset` = `1111_1111_1111_1110_0110B` = `-26D`

### 3.1.1 转移地址

`addr` = `PC` + `SE32(2*offset)` = `0000_0000H (起始地址)`


### 3.1.2 指令的操作与结果

操作：
- `PC + 4 -> x1`
- `PC + SE32(2*offset) -> PC`

结果：
- `x1` 寄存器保存子程序返回时的指令地址
- `PC` 跳转至地址 `0000_0000H` 处，执行子程序

### 3.1.3 跳转目标地址的指令

- `jal x1, offset`

## 3.2 `ret (jr)`

`00008067H` = `0000_0000_0000_0000_1000_0000_0110_0111B`

对照 **RISCV指令格式** 可知该指令属于 `jalr` 指令

`imm` = `0000_0000_0000(offset=imm)`

`rs1` = `00001 (x1)`

`funct3` = `000`

`rd` = `00000 (x0)`

### 3.2.1 转移地址

`addr` = `rs1` + `SE32(offset)` = `x1` = `38H`

### 3.2.2 指令的操作与结果

操作：
- `PC` 跳转至 `x1` 寄存器存储的地址 `0000_0038H` 处

结果：
- 子程序 `BankMove` 调用结束，回到主程序 `main` 

### 3.2.3 跳转目标地址的指令

- `jalr rd offset(rs1)`

> 在本程序中，该指令为特殊形式，其中 **rd = x0** ，**rs1 = x1** 

