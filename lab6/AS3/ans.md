# 1. 实现过程
```assembly
00000000 <BankMove>:
0:  000502b3    add x5,x10,x0
4:  00058333    add x6,x11,x0
8:  000603b3    add x7,x12,x0

0000000c <L1>:
c:  0002ae03    lw x28,0(x5)
10: 01c32023    sw x28,0(x6)
14: 0291        c.addi x5,4
16: 0311        c.addi x6,4
18: 13fd        c.addi x7,-1
1a: fe0399e3    bne x7,x0,c <L1>
1e: 8082        c.jr x1

00000020 <main>:
20: 03000513    addi x10,x0,48
24: 06000593    addi x11,x0,96
28: 4629        c.li x12,10
2a: 3fd9        c.jal 0 <BankMove>
```

## 1.1 子程序调用  
1. `x5` 寄存器存储源数据区域首址，`x6` 寄存器存储目的数据区域首址，`x7` 寄存器存储数据块长度（需转移数据的个数）
2. 利用 `x28` 寄存器作为中间载体，将 `Mem[x5]` 转移至 `Mem[x6]`，循环 10 次
3. 每循环一次，`x5` 和 `x6` 寄存器均加 4（4 个字节，即 1 个字数据的长度），`x7` 寄存器减 1（循环次数减少一次）

## 1.2 子程序返回
1. 程序出口处设有条件分支语句 `bne x7,x0,c <L1>`，若 `x7 != x0`，则跳转至标签 `L1` 处，代表继续循环
2. 若 `x7 == x0`，则顺序执行下一条语句 `c.jr x1`，返回主程序

# 2. `jal` 和 `jr` 的机器代码解析
## 2.1 `2a: 3fd9  c.jal 0 <BankMove>`
- `3fd9H` = `0011_1111_1101_1001B`
- `c.jal 0 <BankMove>` = `jal x1, offset`

### 2.1.1 转移地址 
- `offset` = `11111101011B` = `-21D`
- `addr` = `PC + SE32(2*offset)` = `2aH + -42D` = `0000_0000H`

### 2.1.2 指令的操作与结果
操作:
- `PC + 2 -> x1`
- `PC + SE32(2*offset) -> PC`
  
结果:
- `x1` 寄存器保存子程序返回时的指令地址
- `PC` 跳转至地址 `0000_0000H` 处，执行子程序

### 2.1.3 跳转目标地址的指令 
- `jal x1, offset`

## 2.2 `1e: 8082  c.jr x1`
- `8082H` = `1000_0000_1000_0010B`
- `c.jr x1` = `jalr x0, 0(x1)`

### 2.2.1 转移地址
- `addr` = `x1` = `0000_002cH`

### 2.2.2 指令的操作与结果
操作:
- `PC` 跳转至 `x1` 寄存器存储的地址 `0000_002cH` 处

结果:
- 子程序 `BankMove` 调用结束，回到主程序 `main`

### 2.2.3 跳转目标地址的指令
- `jalr x0, 0(x1)`

# 3.补充

和 **AS2** 一样，本实验也可以通过同样的方法 **反汇编** 出 **32位** 的指令，在此不赘述